# 数组
## 基础

> 数组是拥有固定长度和相同数据类型的一组数据序列。数组可以通过下标随机访问数组元素。

* 长度固定：数组长度必须是常量，一旦定义则不可更改。
* 初始化零值：数组定义之后会使用零值填充
* 长度也是类型：数组长度是数组类型的一部分：因此，var a[5] int和var a[10]int是不同的类型。
* 随机访问：数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1
* 访问越界：将引发panic
* 值类型：赋值和传参会复制整个数组，而不是指针。因此改变副本的值，不会改变本身的值。


数组定义：
```go 
	var a [3]int
	var b [3]int = [3]int{1, 2, 3}
	c := [...]int{1, 2, 3}

	for _, i := range a {
		fmt.Println(i)
	} // 数组a将全部输出0，因为int的零值是0
```
!> 数组定义之后是会被填充的，以数组类型的零值填充。

## 索引
#### go语言数组在使用字面量定义时，可以指定索引位置的值,其后索引自增：
```go
a := [...]int{1, 2, 5: 4, 8, 9: 12}
	for _, i := range a {
		fmt.Print(i, " ")
	}
    // 输出：1 2 0 0 0 4 8 0 0 12
```
代码中`"5:"`和`"9:"`指的是索引位置,意为索引5的位置，值为4，5之后的索引自增，因此8的索引为6

!> 使用索引指定值时，索引值不可与现有索引重复，否则将会出现编译错误
```go
a := [...]int{1, 2, 5: 4, 8, 0: 12}
// 编译错误：
// duplicate index in array literal: 0
```
面试题：
```go 
package main

func main() {
  var x = []int{4:44, 55, 66, 1:77, 88}
  println(len(x), x[2]) 
  // 7 88
}
```

!> go语言函数调用时，都使用的是值传递，数组也不例外，同样传递的是一份拷贝，因此大数组在传递时将很消耗性能。

!> 数组的长度是不可变的，并且数组的长度是数组类型的一部分。
```go 
func main() {
	var a [3]int
	var b [6]int
	fmt.Printf("%T\r\n", a)
	fmt.Printf("%T\r\n", b)
}    
```
输出：
```bash
[3]int
[6]int
```
由上可以看出a和b的类型是不同的，是不能比较的：

```go 
	fmt.Print(a == b)
```
上面代码会出现编译错误：
``` bash
invalid operation: a == b (mismatched types [3]int and [6]int)
```

!> 我们一般是不会直接使用数组的，而是使用[切片](/2/slice.md)。